---
title: Signed Number Representations
date: 2020-06-29 20:06:37
categories:
- CS
tags:
- CS
---

在计算机运算中, 有符号数的表示（signed number representations）需要将负数编码为二进制形式.

在数学中, 任意基数的负数都在最前面加上 `−` 符号来表示. 然而在计算机硬件中, 数字都以无符号的二进制形式表示, 因此需要一种编码负号的方法. 当前有三种方法 ( 先不考虑移码), 用于扩展二进制数字系统, 来表示有符号数.

那么我们先考虑表示整数的以下四种方法:

- 无符号 unsigned
- 原码 sign-and-magnitude
- 反码 ones' complement
- 补码 two's complement



# unsigned

**无符号表示法**表示的是非负整数, 因为 `n` 位二进制数本身通过 0 和 1 表示的就是 `0 ~ 2^n - 1` 个正数, 所以如果我们知道某个二进制数表示的是无符号的数, 就能最快的算出这个无符号数的值.

这里, 最好的例子就是 java 中的 `char` 类型, `char` 本身占用 2 个字节 (16位), 是一个无符号整数, 范围自然就是 `0 ~ 2 ^16 - 1`, 即 `0 ~ 65535`.

也就是说, 我们看到一个 `char ch = 0b1000001`, 即二进制为 `1000001`, 因为是无符号的, 我们不需要考虑首位是 0 还是1, 就直接转为十进制即 65, 再查 ascii 表得到 65 对应的是 `A`, 即 `ch = 'A'`. 

**无符号整数其实就是二进制字面表示, 即看到多少就是多少. 虽然简单, 却是我们认识之后的表示有符号整数的几种表示方法的基础**. 

以下是三种**表示有符号整数的方法**.



# sign-and-magnitude

**原码表示法**也是一种比较好理解的有符号整数表示法. 原码表示法是这样的, 一个二进制数的首位为符号位 (0 表示正, 1 表示负), 其他位以无符号表示法来表示数的绝对值.

比如, 我们以 1 个字节的二进制数 `1000 1111` 来举例: 首位为 1 表示这个数为负数, 去掉首位后变成了 `1111` 即十进制的 15, 15 来表示其绝对值的大小, 所以在原码表示法下, `10001111` 表示的是 -15.

那么可以看出, 原码表示有符号整数, 一个字节 8 位, 去掉首位符号位还有 7 位, 正负数各可以表示 `2^7` 个, 即非负的 `+0 ~ 127` 和非正的 `-0 ~ -127`. 因此以原码表示有符号整数, 一个字节可以表示的范围为 `-127 ~ 127`, **其中 0 出现了两次**, 分别为 `0000 0000` 和 `1000 0000`.

虽然我们很容易能够将以原码表示的二进制换算成其表示的十进制, 但是计算机并没有采用这种方法, 原因有二.

第一, 通过上面我们可以发现, 0 这个数出现了两次.

另一个主要问题是计算逻辑方面的, 比如我们知道在计算机底层, `+1` 操作就是最低位如果是 0 即变 1, 如果是 1 则变 0 前一位 `+1` 并以此类推. 如果采用原码表示, 正数还好, 到了负数就会出现问题. 比如 -2 的以原码表示的一个字节的二进制为 `1000 0010`, 现在将这个二进制数加 1, 变成了 `1000 0011`, 而这个数表示的是 -3.

也就是说, 负数以原码存储的二进制数在进行加减等操作时, 为了保证计算的准确, 还得改变计算机底层加减的逻辑, 这是无法接受的.



# ones' complement

为了解决上面提到的第二种问题, 有了**反码表示法**. 反码表示法是这样的, 一个二进制数的第一位仍为符号位, 剩下位取反之后的无符号数的值作为这个数的绝对值, 符号位和绝对值二者一起来表示一个有符号的数. 什么意思呢, 举个例子, 比如现在告诉我们一个数的以反码表示的二进制数为 `10011010`, 首先这个数是负数, 剩下位为 `11010`, 取反之后为 `00101`, 即十进制的 5, 所以这个数就是 -5.

这个时候我们再来看 `-5 + 1`, `10011010 + 1 = 10011011`, 结果去掉首位再取反, 得到 `00100`, 即十进制的 4, 加上符号位就是 -4, 这样我们就正确计算出了 `-5 + 1 = -4`. 因为只是取了个反, 表示的范围其实没有变化, 负数还是 `-127~-0`, 正数还是 `+0 ~ 127`.

可以发现反码并没有解决 0 重复的问题, `0000 0000` 和 `1111 1111` 依旧都表示的是 0, 但前者是 `+0`, 后者是 `-0`. 那么, 就有这样的问题: `-0 + 1 = ?`, 即 `1111 1111 + 1 = 0000 0000` 即 `+0`, 也就是说, 0 加 1 后还是 0, 这是无法接受的.

抛开以上问题, 回到反码表示本身, 它相比原码解决了一部分计算问题, 但可读性差了. 一方面, 我们看到一个反码表示的二进制数, 确定符号位之后, 得先取反, 然后才知道其绝对值; 另一方面, 我们要用反码的方式表示一个十进制数, 先以其符号确定首位后, 得先将其绝对值的二进制先取反, 加上符号位才是这个数反码的二进制表示. 这不像我们用原码表示一个数那样直观.



# two's complement

为了解决上面遗留的 0 重复的问题, 引入了**补码表示法**. 怎么解决呢? 我们直接把 `-127 ~-0` 全部整体减 1 (也可以理解为左移) 就好了.

比如, 以前 `1111 1111` 表示的是 `-0`, 其加 1 变成了 `+0`. 那么我们让 `1111 1111` 表示成 `-1`, 这样它加 1 等于 0 就符合逻辑了.

怎么操作呢, 我们之前是 `1111 1111` 去掉符号位 `1` 剩下 `111 1111`, 然后取反得到 `000 0000`, 这个 `000 0000`  就是 `1111 1111` 表示的十进制数的绝对值, 那么我们既然要 `1111 1111` 表示 `-1`, 符号位不改变, 虽然说值减 1, 但相当于绝对值加1, 那么 `111 1111` 取反后的 `000 0000` 也加 1 就好了. **也就是一个以反码表示的二进制数 `1111 1111`, 先看其符号位是 1, 表示负数, 去掉符号位后 `111 1111` 取反为 `000 0000`, 再加 1, 即 `000 0001`, 即十进制的 1, 再加上符号位为负,** 也就得到了以补码形式表示的二进制数 `1111 1111` 实际表示的是十进制的 -1.

**因为我们采用了取反, 那么就不存在底层计算问题, 又因为我们取反后加 1, 就不存在双 0 的问题, 这样就解决了有符号数的计算机表示问题.**

既然我们把负数从 `-127~-0` 整体减 1 (也可以理解为左移或者绝对值加 1), 那么一个字节补码表示的有符号整数的范围为 `-128 ~127` 了.

现在, 我们知道看到一个以补码表示的二进制数其表示的十进制数是多少了. 那么反过来, 知道十进制, 我们想知道其补码的二进制呢? 首先, 因为我们只左移了**负数**, **所以正数的原码, 反码和补码都是一样的**. 而对于一个十进制的负数, 符号位确定为 1, 其绝对值减 1 后的二进制再取反, 再加上符号位即为其补码. 比如 -111 的补码怎么求呢? 首先因为是负数, 符号位为 1, `111-1=110`, 其二进制为 `1101110`, 取反为 `0010001`, 加上符号位即 `10010001`. 我们通过以下代码也可以验证:

```java
byte aa = (byte) 0b10010001;
System.out.println(aa); // 输出 -111
```

即十进制负数, 求其补码, 确定符号位后, 其他位为这个数绝对值 - 1 再取反. 

再看一个例子, 求 -128 的补码, 符号位为 1, 128 的无符号二进制为 `1 0000 0000`, 减 1 得到 `1111 1111`, 取反得到 `0000 0000` , 因此, 将首位替换为 1, 即 `1000 0000`.

其实我们也可以发现, 原码表示法也是很直观的:

- 符号位表示正负;
- 去掉符号位, 其他位表示的无符号数越大, 这个数就越大.

有以上理解我们再来看:

- `1000 0000` 首位为负, 其他位为 0, 表示的就是`-128~127` 中最小的负数即 -128;
- `1111 1111` 表示的就是最大的负数, 即 -1;
- `0000 0000` 表示最小的非负数 0;
- `0111 1111` 表示最大的非负数 1.



# Summary

计算机底层是 0 和 1, 并无符号. 为了表示有符号数, 一个以原码表示的二进制数的首位表示符号, 其他位表示这个数的绝对值, 但这样做有重复 0  和加减问题. 为了主要解决加减问题, 引入反码, 一个以反码表示的二进制数的首位仍表示符号, 其他位取反后表示这个数的绝对值, 但仍然存在重复 0 的问题. 为了解决这个问题, 我们想负数整体减 1 (即左移, 也可以认为是绝对值加 1) 来解决重复 0 的问题, 从而引入补码, 一个以补码表示的二进制数的首位仍表示符号, 其他位取反后加 1 来表示这个数的绝对值. 最后, 求一个十进制负数的补码, 可以先确定符号位, 然后将其绝对值减 1 后取反得到其他位. 或者, 求一个十进制负数的补码, 先求出其原码, 保留符号位, 其他位减 1 取反或取反加 1 得到这个数的补码.



# References

1. [有符号数处理](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86#%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F)
2. [Why prefer two's complement over sign-and-magnitude for signed numbers?](https://stackoverflow.com/questions/1125304/why-prefer-twos-complement-over-sign-and-magnitude-for-signed-numbers)